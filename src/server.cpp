#include <iostream>
#include <winsock2.h>
#include "../inc/flatbuffers.h"
#include "../inc/idl_gen_text.cpp"
#include "../inc/idl_parser.cpp"
#include "../inc/util.cpp"
#include <fstream> // C++ header file for file access
#include "../inc/network_Can_generated.h" // This was generated by `flatc`.
#include <typeinfo>
// This was generated by `flatc`.
using namespace std;
using namespace NetworkModels::CAN; // Specified in the schema.

#pragma comment(lib, "ws2_32.lib") // Winsock Library
#pragma warning(disable : 4996)
#define BUFLEN 4096
#define PORT 8888

std::string schemafile;
std::string jsonfile;
SOCKET server_socket;
flatbuffers::FlatBufferBuilder builder(1024);
sockaddr_in server, client;

void formConnection() {
  bool ok = flatbuffers::LoadFile("../inc/network_Can.fbs", false, &schemafile);
  system("title UDP Server");

  // initialise winsock
  WSADATA wsa;
  printf("Initialising Winsock...");
  if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
    printf("Failed. Error Code: %d", WSAGetLastError());
    exit(0);
  }
  printf("Initialised.\n");

  // create a socket
  if ((server_socket = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET) {
    printf("Could not create socket: %d", WSAGetLastError());
  }
  printf("Socket created.\n");

  // prepare the sockaddr_in structure
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = htons(PORT);

  // bind
  if (bind(server_socket, (sockaddr *)&server, sizeof(server)) ==
      SOCKET_ERROR) {
    printf("Bind failed with error code: %d", WSAGetLastError());
    exit(EXIT_FAILURE);
  }
  puts("Bind done.");
}
uint8_t *processData(char *message) {
  auto metaData = GetRegisterFile(message);
  auto bufferData = metaData->buffer();

  std::vector<flatbuffers::Offset<MetaFrame>> MetaFrameVector;
  printf("analyzing the data");
  for (size_t i = 0; i < bufferData->size(); i++) {

    auto frameData = bufferData->Get(i)->frame();
    int frameId = frameData->frame_id();
    uint8_t payload_Data[] = {0, 1, 2, 4};
    auto payload_vector = builder.CreateVector(payload_Data, 4);
    auto payloadLen = frameData->length();
    bool rtr = frameData->rtr();
    auto FrameType = frameData->type();

    auto frame1 = CreateFrame(builder, frameId, payload_vector, payloadLen, rtr,
                              FrameType);

    auto bufferStatus = bufferData->Get(i)->status();
    auto bufferDirection = bufferData->Get(i)->direction();
    auto canIndicator = bufferData->Get(i)->canFD_enabled();
    auto messageTiming = bufferData->Get(i)->timing();

    auto meta_frame = CreateMetaFrame(builder, bufferStatus, bufferDirection,
                                      canIndicator, frame1, messageTiming);
    MetaFrameVector.push_back(meta_frame);
  }
  printf("Payload change completed...\n");

  auto metaFrame = builder.CreateVector(MetaFrameVector);
  auto fileR = CreateRegisterFile(builder, metaFrame);

  builder.Finish(fileR);
  uint8_t *buff = builder.GetBufferPointer();
  printf("sending the updated flatbuffer...\n");
  return buff;
}
void sendAndRecieveData() {
  while (true) {
    printf("Waiting for data...\n");
    fflush(stdout);
    char *message = new char[BUFLEN];

    // try to receive some data, this is a blocking call
    int message_len;
    int slen = sizeof(sockaddr_in);
    if (message_len = recvfrom(server_socket, message, BUFLEN, 0,
                               (sockaddr *)&client, &slen) == SOCKET_ERROR) {
      printf("recvfrom() failed with error code: %d", WSAGetLastError());
      exit(0);
    }

    // print details of the client/peer and the data received
    printf("Received packet from %s:%d\n", inet_ntoa(client.sin_addr),
           ntohs(client.sin_port));

    uint8_t *buf = processData(message);
    // reply the client with 2the same data
    if (sendto(server_socket, (char *)buf, BUFLEN, 0, (sockaddr *)&client,
               sizeof(sockaddr_in)) == SOCKET_ERROR) {
      printf("sendto() failed with error code: %d", WSAGetLastError());
    }

    flatbuffers::Parser parser;
    bool ok1 = parser.Parse(schemafile.c_str());
    GenerateText(parser, message, &jsonfile);
    printf("writing the received message to log file...\n");

    std::ofstream myfile;
    myfile.open("network.log");
    myfile << jsonfile;
    myfile.close();

    std::ofstream ofile("network.can", std::ios::binary);
    ofile.write((char *)buf, BUFLEN);
    ofile.close();

    exit(0);
  }
  closesocket(server_socket);
  WSACleanup();
}
int main() {
  formConnection();
  sendAndRecieveData();
}